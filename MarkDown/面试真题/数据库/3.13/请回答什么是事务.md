**一、事务的介绍**

事务是并发控制单位，是用户定义的一个操作序列，这些操作要么都做，要么都不做，是一个不可分割的工作单位。



事务通常以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。



**二、事务的特征**

- 原子性：事务是数据库的逻辑工作单位，事务中的操作要么都做，要么都不做。



- 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。



- 隔离性：一个事务的执行不能干扰其他的事务。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。



- 持久性：一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。



**三、并发下的问题**

当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：



**脏读**

​    脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

​    例如：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个回滚了操作，则后一个事务所读取的数据就会是不正确的脏数据。



**不可重复读**

​    不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

​    例如：事务A在读取某一数据，而事务B立马修改了这个数据并且提交事务给数据库，事务A再次读取该数据就得到了不同的结果，发生了不可重复读。



**幻读**

​    在一个事务的两次查询中数据笔数不一致，是事务非独立执行时发生的一种现象。

​    例如：有一个事务查询了几列数据，而另一个事务却在此时插入了新的几列数据。先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。



**对比理解**

- 不可重复读和脏读的区别是：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据（读取前一事务提交的数据一些场景下会出现问题）。



- 幻读和不可重复读都是读取了另一条已经提交的事务，所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体。



**四、事务隔离级别**

- Read uncommit（读未提交） 
- Read commit（读已提交） 
- Repeatable read（可重复读） 
- Serializable（序列化） 



**读未提交**

​    在该隔离级别，所有事务都可以看到其它事务未提交的内容数据。此隔离级别没有解决任何并发问题，不常用。



**读已提交**

​    在该隔离级别，一个事务只能读取其它事务已经提交的内容数据。此隔离级别解决了脏读，但没有解决不可重复读和幻读，是ORACLE的默认隔离级别。



**可重复读**

​    在该隔离级别，能保证一个事务之间的多个实例在并发下能读取同一数据。此隔离级别解决了脏读和不可重复读，是MYSQL的默认级别。



**序列化**

​    这是最高的隔离级别，在此隔离级别，事务事务之间只能顺序执行，使之没有任何冲突。序列化解决了脏读，不可重复读和幻读。



隔离级别越高，越能保证数据的完整性和一致性，但是对并发的效率就越低。因此并不是隔离级别越高越好，应根据具体的业务场景选用合适的事务隔离级别。